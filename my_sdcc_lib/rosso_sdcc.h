/* 
 * File:   rosso_sdcc.h
 * Author: sotea
 *
 * Created on May 9, 2016, 2:17 AM
 */

#ifndef ROSSO_SDCC_H
#define	ROSSO_SDCC_H
 
#define INPUT 1
#define OUTPUT 0
#define HIGH 1
#define LOW 0
#define ON 1
#define OFF 0
#define _XTAL_FREQ 64000000
#define MIPS (_XTAL_FREQ/4)

typedef enum {
	FALSE = 0, TRUE
} bool_t;

typedef enum { 
	CLEAR = 0, SET 
} bit_t;

#include <stdint.h>

typedef union {
    uint8_t val;
    struct {
        uint8_t b0 :1;
        uint8_t b1 :1;
        uint8_t b2 :1;
        uint8_t b3 :1;
        uint8_t b4 :1;
        uint8_t b5 :1;
        uint8_t b6 :1;
        uint8_t b7 :1;
    } bits;
} uint8_val_t, uint8_bits_t;

/* Macros to access bytes within words and words within longs */
#define LOW_BYTE(x)     ((unsigned char)((x)&0xFF))
#define HIGH_BYTE(x)    ((unsigned char)(((x)>>8)&0xFF))
#define LOW_WORD(x)     ((unsigned short int)((x)&0xFFFF))
#define HIGH_WORD(x)    ((unsigned short int)(((x)>>16)&0xFFFF))

#include <pic18f46k22.h> /* Our ATmega644P replacement */

/* Accurate read/write macros for 16-Bit timers */
/*** please note, the timer needs to be enabled ***
 *** to handle 16-Bit read/write operations for ***
 *** these routines to be of benefit ***/
#define T1RD16ON  T1CON|=0x80
#define T3RD16ON  T3CON|=0x80
#define WRITETIMER0(x) ((void)(TMR0H=((x)>>8),TMR0L=((x)&0xFF)))
#define WRITETIMER1(x) ((void)(TMR1H=((x)>>8),TMR1L=((x)&0xFF)))
#define WRITETIMER3(x) ((void)(TMR3H=((x)>>8),TMR3L=((x)&0xFF)))
#define READTIMER0() (TMR0)
#define READTIMER1() (TMR1)
#define READTIMER3() (TMR3)


/* sei()= Set interrupts (Activate global interrupts on high/low priority system)*/
#define sei() RCON=0;RCONbits.IPEN=1;INTCONbits.PEIE=1;INTCONbits.GIE=1;
/* cli()= Clear Interrupts (Deactivate global interrupts)*/
#define cli() INTCONbits.GIE=0;

#ifndef __CONCAT2
  #define __CONCAT2(a, b)       a##b
#endif

#ifndef __CONCAT
  #define __CONCAT(a, b)        __CONCAT2(a, b)
#endif

#define __CONFIG(address, value) \
    static const __code unsigned char __at(address) __CONCAT(_conf, __LINE__) = (value)

#define Nop()                   __asm nop __endasm
#define delay1tcy()             __asm nop __endasm
#define ClrWdt()                __asm clrwdt __endasm
#define Sleep()                 __asm sleep __endasm
#define Reset()                 __asm reset __endasm

/* To pointer manipulations. (From the sdcc/src/pic16/gen.h file.) */
#define GPTR_TAG_MASK           0xC0    /* Generated by the device-manager.pl program. */
#define GPTR_TAG_DATA           0x80
#define GPTR_TAG_EEPROM         0x40
#define GPTR_TAG_CODE           0x00

#include <delay.h>

/* The following delays are true for PIC18F46K22 at 64MHz (16MIPS).
 * It always will be at 16MIPS because this is a replacement for ATmega644P
 */
#define delay_500ns() Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop();
#define delay_1us() Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop(); Nop();
#define delay_2us() delay_1us();delay_1us();
#define delay_3us() delay_1us();delay_1us();delay_1us();
#define delay_4us() delay_1us();delay_1us();delay_1us();delay_1us();
#define delay_5us() delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();
#define delay_6us() delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();
#define delay_7us() delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();
#define delay_8us() delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();
#define delay_9us() delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();delay_1us();

#define delay_10us() delay10tcy(16)  //= 10 x 16 / 16 = 10us
#define delay_15us() delay10tcy(24)  //= 10 x 24 / 16 = 15us
#define delay_20us() delay10tcy(32)  //= 10 x 32 / 16 = 20us
#define delay_25us() delay10tcy(40)  //= 10 x 40 / 16 = 25us
#define delay_30us() delay10tcy(48)  //= 10 x 48 / 16 = 30us
#define delay_35us() delay10tcy(56)  //= 10 x 56 / 16 = 35us
#define delay_40us() delay10tcy(64)  //= 10 x 64 / 16 = 40us
#define delay_45us() delay10tcy(72)  //= 10 x 72 / 16 = 45us
#define delay_50us() delay10tcy(80)  //= 10 x 80 / 16 = 50us
#define delay_55us() delay10tcy(88)  //= 10 x 88 / 16 = 55us
#define delay_60us() delay10tcy(96)  //= 10 x 96 / 16 = 60us
#define delay_65us() delay10tcy(104)  //= 10 x 104 / 16 = 65us
#define delay_70us() delay10tcy(112)  //= 10 x 112 / 16 = 70us
#define delay_75us() delay10tcy(120)  //= 10 x 120 / 16 = 75us
#define delay_80us() delay10tcy(128)  //= 10 x 128 / 16 = 80us
#define delay_85us() delay10tcy(136)  //= 10 x 136 / 16 = 85us
#define delay_90us() delay10tcy(144)  //= 10 x 144 / 16 = 90us
#define delay_95us() delay10tcy(152)  //= 10 x 152 / 16 = 95us
#define delay_100us() delay10tcy(160)  //= 10 x 160 / 16 = 100us

#define delay_200us() delay100tcy(32) //= 100 x 32 / 16 = 200us
#define delay_300us() delay100tcy(48) //= 100 x 48 / 16 = 300us
#define delay_400us() delay100tcy(64) //= 100 x 64 / 16 = 400us
#define delay_500us() delay100tcy(80) //= 100 x80 / 16 = 500us = 0.5ms
#define delay_1ms() delay100tcy(160) //= 100 x160 / 16 = 1000us = 1ms

#define delay_2ms() delay1ktcy(32) //= 1000 x 32 / 16 = 2000us = 2ms
#define delay_3ms() delay1ktcy(48) //= 1000 x 48 / 16 = 3000us = 3ms
#define delay_4ms() delay1ktcy(64) //= 1000 x 64 / 16 = 4000us = 4ms
#define delay_5ms() delay1ktcy(80) //= 1000 x 80 / 16 = 5000us = 5ms
#define delay_6ms() delay1ktcy(96) //= 1000 x 96 / 16 = 6000us = 6ms
#define delay_7ms() delay1ktcy(112) //= 1000 x 112 / 16 = 7000us = 7ms
#define delay_8ms() delay1ktcy(128) //= 1000 x 128 / 16 = 8000us = 8ms
#define delay_9ms() delay1ktcy(144) //= 1000 x 144 / 16 = 9000us = 9ms
#define delay_10ms() delay1ktcy(160) //= 1000 x 160 / 16 = 10000us = 10ms
#define delay_15ms() delay1ktcy(240) //= 1000 x 240 / 16 = 15000us = 15ms

#define delay_20ms() delay10ktcy(32) //= 10000 x 32 / 16 = 20000us = 20ms
#define delay_25ms() delay10ktcy(40) //= 10000 x 40 / 16 = 25000us = 25ms
#define delay_30ms() delay10ktcy(48) //= 10000 x 48 / 16 = 30000us = 30ms
#define delay_35ms() delay10ktcy(56) //= 10000 x 56 / 16 = 35000us = 35ms
#define delay_40ms() delay10ktcy(64) //= 10000 x 64 / 16 = 40000us = 40ms
#define delay_45ms() delay10ktcy(72) //= 10000 x 72 / 16 = 45000us = 45ms
#define delay_50ms() delay10ktcy(80) //= 10000 x 80 / 16 = 50000us = 50ms
#define delay_55ms() delay10ktcy(88)  //= 10000 x 88 / 16 = 55ms
#define delay_60ms() delay10ktcy(96)  //= 10000 x 96 / 16 = 60ms
#define delay_65ms() delay10ktcy(104)  //= 10000 x 104 / 16 = 65ms
#define delay_70ms() delay10ktcy(112)  //= 10000 x 112 / 16 = 70ms
#define delay_75ms() delay10ktcy(120)  //= 10000 x 120 / 16 = 75ms
#define delay_80ms() delay10ktcy(128)  //= 10000 x 128 / 16 = 80ms
#define delay_85ms() delay10ktcy(136)  //= 10000 x 136 / 16 = 85ms
#define delay_90ms() delay10ktcy(144)  //= 10000 x 144 / 16 = 90ms
#define delay_95ms() delay10ktcy(152)  //= 10000 x 152 / 16 = 95ms
#define delay_100ms() delay10ktcy(160)  //= 10000 x 160 / 16 = 100ms
#define delay_150ms() delay10ktcy(240)  //= 10000 x 240 / 16 = 150ms

/* 
 * Just for the illusion, as these two are introducing even more delay
 */
void _delay_us(uint16_t x){
    uint16_t i;
    for(i=0; i<x; i++){
        delay_1us();
    }
}

void _delay_ms(uint16_t x){
    uint16_t i;
    for(i=0; i<x; i++){
        delay_1ms();
    }
}
/* end */

#define AllDigital() ANSELA=0;ANSELB=0;ANSELC=0;ANSELD=0;ANSELE=0;ADCON0=0;ADCON1=0;ADCON2=0;CM1CON0=0;CM2CON0=0;CM2CON1=0;
#ifdef ONBOARD /* onboard definitions for "Il Pinguino Rosso" dev. board*/
#define OnBoardLED         LATCbits.LATC2
#define OnBoardButton      PORTAbits.RA4
#define OnBoardLED_dir     TRISCbits.RC2
#define OnBoardButton_dir  TRISAbits.RA4
#endif

/*  
 * BOOT or NOBOOT, that is the question!
 */
 
#ifdef NOBOOT // then set the configuration bits for 16MHz crystal with PLL at 64MHz maximum speed
#pragma config FOSC = HSMP      // Oscillator Selection bits (HS oscillator (medium power 4-16 MHz))
#pragma config PLLCFG = ON      // 4X PLL Enable (Oscillator multiplied by 4)
#pragma config PRICLKEN = ON    // Primary clock enable bit (Primary clock is always enabled)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
#pragma config IESO = OFF       // Internal/External Oscillator Switchover bit (Oscillator Switchover mode disabled)

// CONFIG2L
#pragma config PWRTEN = OFF     // Power-up Timer Enable bit (Power up timer disabled)
#pragma config BOREN = OFF      // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware and software)
#pragma config BORV = 190       // Brown Out Reset Voltage bits (VBOR set to 1.90 V nominal)

// CONFIG2H
#pragma config WDTEN = OFF      // Watchdog Timer Enable bits (Watch dog timer is always disabled. SWDTEN has no effect.)
#pragma config WDTPS = 32768    // Watchdog Timer Postscale Select bits (1:32768)

// CONFIG3H
#pragma config CCP2MX = PORTC1  // CCP2 MUX bit (CCP2 input/output is multiplexed with RC1)
#pragma config PBADEN = ON      // PORTB A/D Enable bit (PORTB<5:0> pins are configured as analog input channels on Reset)
#pragma config CCP3MX = PORTB5  // P3A/CCP3 Mux bit (P3A/CCP3 input/output is multiplexed with RB5)
#pragma config HFOFST = ON      // HFINTOSC Fast Start-up (HFINTOSC output and ready status are not delayed by the oscillator stable status)
#pragma config T3CMX = PORTC0   // Timer3 Clock input mux bit (T3CKI is on RC0)
#pragma config P2BMX = PORTD2   // ECCP2 B output mux bit (P2B is on RD2)
#pragma config MCLRE = EXTMCLR  // MCLR Pin Enable bit (MCLR pin enabled, RE3 input pin disabled)

// CONFIG4L
#pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
#pragma config LVP = OFF        // Single-Supply ICSP Enable bit (Single-Supply ICSP disabled)
#pragma config XINST = OFF      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))

// CONFIG5L
#pragma config CP0 = OFF        // Code Protection Block 0 (Block 0 (000800-003FFFh) not code-protected)
#pragma config CP1 = OFF        // Code Protection Block 1 (Block 1 (004000-007FFFh) not code-protected)
#pragma config CP2 = OFF        // Code Protection Block 2 (Block 2 (008000-00BFFFh) not code-protected)
#pragma config CP3 = OFF        // Code Protection Block 3 (Block 3 (00C000-00FFFFh) not code-protected)

// CONFIG5H
#pragma config CPB = OFF        // Boot Block Code Protection bit (Boot block (000000-0007FFh) not code-protected)
#pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)

// CONFIG6L
#pragma config WRT0 = OFF       // Write Protection Block 0 (Block 0 (000800-003FFFh) not write-protected)
#pragma config WRT1 = OFF       // Write Protection Block 1 (Block 1 (004000-007FFFh) not write-protected)
#pragma config WRT2 = OFF       // Write Protection Block 2 (Block 2 (008000-00BFFFh) not write-protected)
#pragma config WRT3 = OFF       // Write Protection Block 3 (Block 3 (00C000-00FFFFh) not write-protected)

// CONFIG6H
#pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
#pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-0007FFh) not write-protected)
#pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)

// CONFIG7L
#pragma config EBTR0 = OFF      // Table Read Protection Block 0 (Block 0 (000800-003FFFh) not protected from table reads executed in other blocks)
#pragma config EBTR1 = OFF      // Table Read Protection Block 1 (Block 1 (004000-007FFFh) not protected from table reads executed in other blocks)
#pragma config EBTR2 = OFF      // Table Read Protection Block 2 (Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks)
#pragma config EBTR3 = OFF      // Table Read Protection Block 3 (Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks)

// CONFIG7H
#pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0007FFh) not protected from table reads executed in other blocks)
#endif //NOBOOT

#endif	/* ROSSO_SDCC_H */


